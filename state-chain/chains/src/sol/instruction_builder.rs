// Copyright 2025 Chainflip Labs GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

//! This file contains a Instruction builder for the Solana chain.
//!
//! The builder is used to build single Solana Instruction used for Vault Swap.
//!
//! Such Instruction can be signed and sent to the Program on Solana directly to invoke
//! certain functions.

use crate::{
	address::EncodedAddress,
	sol::{
		sol_tx_core::{
			consts::{SOL_USDC_DECIMAL, SYSTEM_PROGRAM_ID, TOKEN_PROGRAM_ID},
			program_instructions::swap_endpoints::{
				SwapEndpointProgram, SwapNativeParams, SwapTokenParams,
			},
		},
		SolAddress, SolAmount, SolApiEnvironment, SolInstruction, SolPubkey,
	},
	CcmChannelMetadata,
};
use cf_primitives::chains::assets::any::Asset;
use sp_std::vec::Vec;

fn system_program_id() -> SolAddress {
	SYSTEM_PROGRAM_ID
}

fn token_program_id() -> SolAddress {
	TOKEN_PROGRAM_ID
}

pub struct SolanaInstructionBuilder;

impl SolanaInstructionBuilder {
	pub fn x_swap_native(
		
	) -> SolInstruction {
		todo!("Create the instruction using `SwapEndpointProgram::with_id(api_environment.swap_endpoint_program).x_swap_token(...)`")
	}

	pub fn x_swap_usdc(
		
	) -> SolInstruction {
		todo!("Create the instruction using SwapEndpointProgram::with_id(api_environment.swap_endpoint_program).x_swap_token(...)");
	}
}

#[cfg(test)]
mod test {
	use super::*;
	use crate::{
		cf_parameters::build_cf_parameters,
		sol::{
			signing_key::SolSigningKey,
			sol_tx_core::{
				consts::{const_address, MAX_TRANSACTION_LENGTH},
				sol_test_values::*,
			},
			SolAddress, SolAddressLookupTableAccount, SolHash, SolVersionedMessage,
			SolVersionedTransaction,
		},
		ChannelRefundParameters,
	};
	use cf_primitives::{
		chains::Solana, AccountId, AffiliateAndFee, AffiliateShortId, BasisPoints, DcaParameters,
		MAX_AFFILIATES,
	};
	use sp_core::ConstU32;
	use sp_runtime::BoundedVec;

	// private key: ead22312d80f573924a27595271bd2ec0aa20a270587c8a399136166561ea58c
	const DESTINATION_ADDRESS_ETH: EncodedAddress =
		EncodedAddress::Eth(hex_literal::hex!("756FBdE9c71EaE05C2f7169f816b0Bd11D978020"));

	// Test Solana accounts. Generated by
	// ```rust
	// let key = SolSigningKey.new();
	// key.print_pub_and_private_keys();
	// ```

	//const DESTINATION_ADDRESS_KEY_BYTES: [u8; 32] = [242, 33, 23, 21, 58, 254, 23, 134, 199, 91,
	// 117, 2, 20, 116, 174, 15, 191, 69, 254, 42, 135, 88, 210, 88, 225, 158, 31, 184, 181, 50, 16,
	// 195];
	const DESTINATION_ADDRESS_SOL: SolAddress =
		const_address("BdyHK5DckpAFGcbZveGLPjjMEaADGfNeqcRXKoyd33kA");

	const FROM_KEY_BYTES: [u8; 32] = [
		130, 14, 62, 77, 129, 146, 185, 187, 159, 15, 165, 161, 93, 111, 249, 198, 145, 149, 193,
		229, 147, 69, 73, 190, 10, 208, 151, 131, 194, 205, 116, 232,
	];
	const FROM: SolAddress = const_address("EwgZksaPybTUyhcEMn3aR46HZokR4NH6d1Wy8d51qZ6G");

	const EVENT_DATA_ACCOUNT_KEY_BYTES: [u8; 32] = [
		133, 220, 70, 223, 197, 127, 106, 46, 178, 73, 164, 200, 88, 128, 97, 144, 20, 132, 211,
		34, 196, 159, 28, 118, 5, 209, 12, 245, 241, 223, 8, 67,
	];
	const EVENT_DATA_ACCOUNT: SolAddress =
		const_address("9acHwMGmeoMr5o8Cw1V2U4HjMQwhced3eQP31yYEhYDU");

	//const TOKEN_SUPPORTED_ACCOUNT_KEY_BYTES: [u8; 32] = [0, 81, 206, 126, 204, 53, 163, 79, 5,
	// 119, 184, 1, 97, 237, 114, 120, 23, 6, 227, 206, 239, 132, 130, 212, 241, 12, 21, 185, 66,
	// 252, 127, 8];
	const TOKEN_SUPPORTED_ACCOUNT: SolAddress =
		const_address("48vfkGMyVDUNq689aocfYQsoqubZjjme7cja21cbnMnK");

	const BROKER_COMMISSION: BasisPoints = 1u16;
	const BOOST_FEE: u8 = 2u8;
	const INPUT_AMOUNT: SolAmount = 1_234_567_890u64;

	const BLOCKHASH: SolHash = SolHash([0x00; 32]);

	// Sisyphos broker account: 0xa622ebf634ff6cdafe1b7912d8699b34a4d9a08598af0b0c90eaf1e912de1f19
	fn broker_id() -> AccountId {
		AccountId::from(hex_literal::hex!(
			"a0edda1a4beee4fe2df32c0802aa6759da49ae6165fcdb5c40d7f4cd5a30db0e"
		))
	}

	fn channel_refund_parameters() -> ChannelRefundParameters<SolAddress> {
		ChannelRefundParameters {
			min_price: sp_core::U256::default(),
			refund_address: DESTINATION_ADDRESS_SOL,
			retry_duration: 10u32,
		}
	}

	fn affiliate_and_fees() -> BoundedVec<AffiliateAndFee, ConstU32<MAX_AFFILIATES>> {
		vec![
			AffiliateAndFee { affiliate: AffiliateShortId(1u8), fee: 10u8 },
			AffiliateAndFee { affiliate: AffiliateShortId(2u8), fee: 20u8 },
		]
		.try_into()
		.unwrap()
	}

	fn dca_parameters() -> DcaParameters {
		DcaParameters { number_of_chunks: 10u32, chunk_interval: 20u32 }
	}

	fn cf_parameter(with_ccm: bool) -> Vec<u8> {
		build_cf_parameters::<Solana>(
			channel_refund_parameters(),
			Some(dca_parameters()),
			BOOST_FEE,
			broker_id(),
			BROKER_COMMISSION,
			affiliate_and_fees(),
			with_ccm.then_some(&ccm_parameter().channel_metadata),
		)
	}

	fn into_transaction(
		instructions: SolInstruction,
		payer: SolPubkey,
		alt: &[SolAddressLookupTableAccount],
	) -> SolVersionedTransaction {
		// Build mock Transaction for testing.
		let transaction = SolVersionedTransaction::new_unsigned(SolVersionedMessage::new(
			&[instructions],
			Some(payer),
			Default::default(),
			alt,
		));

		let mock_serialized_tx = transaction
			.clone()
			.finalize_and_serialize()
			.expect("Transaction building must succeed.");

		assert!(
			mock_serialized_tx.len() < MAX_TRANSACTION_LENGTH,
			"Transaction exceeded max length"
		);

		transaction
	}

	#[test]
	fn can_build_x_swap_native_instruction_no_ccm() {
		let transaction = todo!("create Transaction with into_transaction()");

		// Encoded hex 
		let expected_serialized_tx = hex_literal::hex!("02dfa8826b2ea2083529b313a8d40c8be9ab1516224c3a464bec13054f00522ac70564cd805a9dbd96de13a474ae2142dd65ec18dbb718a0d2f539cea29fe76c08eb0ac39fd749f5a2fca83c66617c56b4db6ab25b99b0374aece6b461df30184cc0ced32b72b2545337f4ce7adcb3caf8be792b17a30a6566674772e74bed1a0a8002000104cf2a079e1506b29d02c8feac98d589a9059a740891dcd3dab6c64b3160bc28317f799121d6c125f312c5f423a51959ce1d41df06af977e9a17f48b2c82ecf89ff79d5e026f12edc6443a534b2cdd5072233989b415d7596573e743f3e5b386fb1ef91c791d2aa8492c90f12540abd10056ce5dd8d9ab08461476c1dcc16229380000000000000000000000000000000000000000000000000000000000000000010306060200010405ab01a3265ce2f3698dc4d2029649000000000100000014000000756fbde9c71eae05c2f7169f816b0bd11d978020010000000076000000000a0000009e0d6a70e12d54edf90971cc977fa26a1d3bb4b0b26e72470171c36b0006b01f0000000000000000000000000000000000000000000000000000000000000000010a0000001400000002a0edda1a4beee4fe2df32c0802aa6759da49ae6165fcdb5c40d7f4cd5a30db0e010008010a0214013001afd71da9456a977233960b08eba77d2e3690b8c7259637c8fb8f82cf58a10108020c02").to_vec();

		let from_signing_key = SolSigningKey::from_bytes(&FROM_KEY_BYTES).unwrap();
		let event_data_account_signing_key =
			SolSigningKey::from_bytes(&EVENT_DATA_ACCOUNT_KEY_BYTES).unwrap();

		test_constructed_transaction_with_signer(
			transaction,
			expected_serialized_tx,
			vec![from_signing_key, event_data_account_signing_key].into(),
			BLOCKHASH.into(),
		);
	}

	#[test]
	fn can_build_x_swap_native_instruction_with_ccm() {
		todo!()
	}

	#[test]
	fn can_build_x_swap_token_instruction_no_ccm() {
		todo!()
	}

	#[test]
	fn can_build_x_swap_token_instruction_with_ccm() {
		todo!()
	}
}
